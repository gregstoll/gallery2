<?php
/*
 * Gallery - a web based photo album viewer and editor
 * Copyright (C) 2000-2007 Bharat Mediratta
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or (at
 * your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA  02110-1301, USA.
 */
/**
 * @package map
 * @author Eric Daniel <ehdaniel@gmail.com>
 * @version $Revision: 1576 $
 *
 * based on a code from Alan Harder <alan.harder@sun.com>
 */
// Session key for storing item admin mode
define('map_SESSION_KEY', 'mapv3.adminMode.itemId');

GalleryCoreApi::requireOnce('modules/mapv3/classes/mapv3Interface_1_0.class');
GalleryCoreApi::requireOnce('modules/mapv3/classes/GoogleMapUtilities.class');

/**
 * A helper class for the map module.
 *
 * @package map
 * @subpackage Classes
 */
class mapv3Helper extends mapv3Interface_1_0 // and GalleryEventListener
{
	/**
	 * Load and decode module parameters
	 *
	 * @param int id of container; check for album-specific settings
	 * @param boolean fallback to site-defaults if no album-specific settings found
	 * @param array sets to load; all by default
	 * @return array GalleryStatus a status code
	 *               mixed containing custom field data
	 *               boolean true if album-specific settings are returned
	 * @static
	 */
	public static function loadParameters(
		$containerId = 0,
		$fallback = true,
		$sets = array('common', 'album', 'photo')
	) {
		$isContainer        = ($containerId > 0);
		list($ret, $param)  = GalleryCoreApi::fetchAllPluginParameters('module', 'mapv3', $containerId);

		if ($ret) {
			return array($ret->wrap(__FILE__, __LINE__), null, null);
		}

		if (empty($param) && $containerId > 0 && $fallback) {
			list($ret, $param) = GalleryCoreApi::fetchAllPluginParameters('module', 'mapv3');

			if ($ret) {
				return array($ret->wrap(__FILE__, __LINE__), null, null);
			}
			$isContainer = false;
		}

		foreach ($sets as $set) {
			$result[$set] = array();

			foreach ((!empty($param[$set]) ? explode('|', $param[$set]) : array()) as $tmp) {
				$list           = explode('`', $tmp);
				$result[$set][] = array(
					'field'             => $list[0],
					'summary'           => ($list[1] == '1'),
					'detail'            => ($list[2] == '1'),
					'choices'           => array_splice($list, 3),
				);
			}
		}

		return array(null, $result, $isContainer);
	}

	/**
	 * Encode and save module parameters
	 *
	 * @param array data to save
	 * @param int id of container; to save album-specific settings
	 * @return GalleryStatus a status code
	 * @static
	 */
	public static function saveParameters($param, $containerId = 0) {
		foreach (array('common', 'album', 'photo') as $set) {
			if (!isset($param[$set])) {
				continue;
			}
			$list = array();
			/** @todo: fix this to use serialize/unserialize */
			foreach ($param[$set] as $item) {
				$list[] = $item['field'] . '`' . ($item['summary'] ? 1 : 0) . '`'
				  . ($item['detail'] ? 1 : 0)
				  . (!empty($item['choices']) ? ('`' . implode('`', $item['choices'])) : '');
			}
			$ret = GalleryCoreApi::setPluginParameter(
				'module',
				'mapv3',
				$set,
				implode('|', $list),
				$containerId
			);

			if ($ret) {
				return $ret->wrap(__FILE__, __LINE__);
			}
		}

		return null;
	}

	/**
	 * Add new custom field in given set/container.
	 *
	 * @param string field name
	 * @param string set (common, album, photo)
	 * @param int id of container; to save album-specific settings
	 * @return array object GalleryStatus a status code
	 *               boolean true on success, false on duplicate field name
	 * @static
	 */
	public static function addField($newField, $set, $containerId = 0) {
		list($ret, $param) = mapv3Helper::loadParameters($containerId, false);

		if ($ret) {
			return $ret->wrap(__FILE__, __LINE__);
		}

		foreach ($param as $list) {
			$idx = mapv3Helper::findParameter($list, $newField);

			if ($idx >= 0) {
				return array(null, false);
			}
		}
		$param[$set][] = array(
			'field'                      => $newField,
			'summary'                    => false,
			'detail'                     => true,
			'choices'                    => array(),
		);
		$ret           = mapv3Helper::saveParameters(
			array(
				$set => $param[$set],
			),
			$containerId
		);

		if ($ret) {
			return $ret->wrap(__FILE__, __LINE__);
		}

		return array(null, true);
	}

	/**
	 * Find a field in a parameter list
	 *
	 * @param array parameter list
	 * @param string field to find
	 * @return int index or -1 if not found
	 * @static
	 */
	public static function findParameter(&$list, $field) {
		foreach ($list as $i => $item) {
			if ($item['field'] == $field) {
				return $i;
			}
		}

		return -1;
	}

	/**
	 * Delete custom field values for given field
	 *
	 * @param string field to delete
	 * @param int id of container, to delete only for specific album
	 * @param string 'album' or 'photo' -- don't delete values for items of this type
	 * @return GalleryStatus a status code
	 * @static
	 */
	public static function deleteField($field, $containerId = 0, $exceptType = '') {
		switch ($exceptType) {
			case 'album':
				$setTypes = array(0, 2);
				// Fall Through
			case 'photo':
				if (!isset($setTypes)) {
					$setTypes = array(0, 1);
				}
				$ret = GalleryCoreApi::removeMapEntry(
					'mapv3Map',
					array(
						'field'   => $field,
						'setId'   => $containerId,
						'setType' => $setTypes,
					)
				);

				if ($ret) {
					return $ret->wrap(__FILE__, __LINE__);
				}

				break;

			default:
				$ret = GalleryCoreApi::removeMapEntry(
					'mapv3Map',
					array(
						'field' => $field,
						'setId' => $containerId,
					)
				);

				if ($ret) {
					return $ret->wrap(__FILE__, __LINE__);
				}
		}

		return null;
	}

	/**
	 * Load custom field values for specified items
	 *
	 * @param array  object GalleryEntity item, ...
	 * @param string if specified then only include fields for that view (summary or detail)
	 * @param string if specified then include in results all valid fields for
	 *               this type, even if item has no value
	 * @return array GalleryStatus a status code
	 *               array(itemId => array(field => value))
	 *               array(itemId => array) loadParameters results
	 *           array(itemId => boolean) loadParameters results
	 * @static
	 */
	public static function fetchFieldValues($items, $viewType = null, $fillSet = null) {
		global $gallery;
		$data = $result = array();

		if (empty($items) || !is_array($items)) {
			return array(
				GalleryCoreApi::error(ERROR_BAD_PARAMETER, __FILE__, __LINE__),
				null,
				null,
				null,
			);
		}

		foreach ($items as $item) {
			$itemId          = (int)$item->getId();
			$itemIds[]       = $itemId;
			$result[$itemId] = array();
			$containerId     = GalleryUtilities::isA($item, 'GalleryAlbumItem') ? (int)$itemId : (int)$item->getParentId();

			list($ret, $param[$itemId], $isContainer[$itemId]) = mapv3Helper::loadParameters($containerId);

			if ($ret) {
				return array($ret, null);
			}
		}

		$query = '
	SELECT [mapv3Map::itemId], [mapv3Map::field], [mapv3Map::value]
	FROM [mapv3Map]
	WHERE [mapv3Map::itemId] IN (' . GalleryUtilities::makeMarkers($itemIds) . ')';

		list($ret, $searchResults) = $gallery->search($query, $itemIds);

		if ($ret) {
			return array($ret, null);
		}

		while ($rec = $searchResults->nextResult()) {
			$data[(int)$rec[0]][$rec[1]] = $rec[2];
		}

		foreach ($itemIds as $itemId) {
			foreach (array('common', 'album', 'photo') as $set) {
				foreach ($param[$itemId][$set] as $it) {
					$field = $it['field'];

					if (isset($viewType) && !$it[$viewType]) {
						continue;
					}

					if (isset($data[$itemId][$field])) {
						$result[$itemId][$field] = $data[$itemId][$field];
					} elseif (isset($fillSet) && ($set == 'common' || $set == $fillSet)) {
						$result[$itemId][$field] = '';
					}
				}
			}
		}

		return array(null, $result, $param, $isContainer);
	}

	/**
	 * Save custom field values for specified item, overwriting any existing values
	 *
	 * @param object GalleryEntity item
	 * @param array (field => value)
	 * @return GalleryStatus a status code
	 * @static
	 */
	public static function saveFieldValues(&$item, $fields) {
		$set                = (GalleryUtilities::isA($item, 'GalleryAlbumItem')) ? 1 : ((GalleryUtilities::isA($item, 'GalleryPhotoItem')) ? 2 : 0);
		$containerId        = ($set == 1) ? $item->getId() : $item->getParentId();
		list($ret, $param)  = GalleryCoreApi::fetchAllPluginParameters('module', 'mapv3', $containerId);

		if ($ret) {
			return $ret->wrap(__FILE__, __LINE__);
		}
		$isContainer = !empty($param);

		$ret = GalleryCoreApi::removeMapEntry(
			'mapv3Map',
			array(
				'itemId' => $item->getId(),
			)
		);

		if ($ret) {
			return $ret->wrap(__FILE__, __LINE__);
		}

		foreach ($fields as $field => $value) {
			if (!empty($value)) {
				$ret = GalleryCoreApi::addMapEntry(
					'mapv3Map',
					array(
						'itemId'                  => $item->getId(),
						'field'                   => $field,
						'value'                   => $value,
						'setId'                   => $isContainer ? $containerId : 0,
						'setType'                 => $set,
					)
				);

				if ($ret) {
					return $ret->wrap(__FILE__, __LINE__);
				}
			}
		}

		return null;
	}

	/**
	 * Event handler for GalleryEntity::delete event
	 * Remove any custom field values for entity being deleted.
	 *
	 * @see GalleryEventListener::handleEvent
	 */
	public function handleEvent($event) {
		GalleryCoreApi::requireOnce('modules/mapv3/classes/GoogleMapUtilities.class');

		if ($event->getEventName() == 'GalleryEntity::delete') {
			$item = $event->getEntity();
			$ret  = GalleryCoreApi::removeMapEntry(
				'mapv3Map',
				array(
					'itemId' => $item->getId(),
				)
			);

			if ($ret) {
				return $ret->wrap(__FILE__, __LINE__);
			}
		}

		if ($event->getEventName() == 'GalleryEntity::save') {
			$item = $event->getEntity();

			if ($item->getEntityType() == 'GalleryPhotoItem') {
				list($ret, $coords) = GoogleMapUtilities::getGPSCoordsFromExif($item);

				if ($ret) {
					return array($ret->wrap(__FILE__, __LINE__), null);
				}

				if ($coords != null) {
					$fields['GPS'] = $coords;
					$ret           = mapv3Helper::saveFieldValues($item, $fields);

					if ($ret) {
						return $ret->wrap(__FILE__, __LINE__);
					}
				}
			}
		}

		return array(null, null);
	}

	/**
	 * Handler for Custom Field Admin actions
	 *
	 * @param mixed form data
	 * @param int id of container, for album-specific settings
	 * @return array GalleryStatus a status code
	 *               mixed status to return from controller
	 * @static
	 */
	public static function handleAdminAction($form, $containerId = 0) {
		$status = array();

		if (isset($form['action']['save'])) {
			list($ret, $param) = mapv3Helper::loadParameters($containerId, false);

			if ($ret) {
				return $ret->wrap(__FILE__, __LINE__);
			}

			foreach (array('common', 'album', 'photo') as $set) {
				$newParam[$set] = array();

				if (isset($form[$set]['index'])) {
					foreach ($form[$set]['index'] as $newidx => $oldidx) {
						$newParam[$set][] = array(
							'field'   => $param[$set][$oldidx]['field'],
							'summary' => isset($form[$set]['summary'][$newidx]),
							'detail'  => isset($form[$set]['detail'][$newidx]),
							'choices' => $param[$set][$oldidx]['choices'],
						);
					}
				}
			}
			$ret = mapv3Helper::saveParameters($newParam, $containerId);

			if ($ret) {
				return $ret->wrap(__FILE__, __LINE__);
			}
			$status['saved'] = 1;
		} elseif (isset($form['action']['add'])) {
			foreach ($form['action']['add'] as $set => $tmp) {
			} /** @todo: Is this intended--empty action for foreach? */
			$newField = str_replace('|', ':', str_replace('`', '&#039;', $form[$set]['newField']));

			if (empty($newField)) {
				$status['error']['empty'] = 1;

				return array(null, $status);
			}
			list($ret, $added) = mapv3Helper::addField($newField, $set, $containerId);

			if ($ret) {
				return $ret->wrap(__FILE__, __LINE__);
			}

			if ($added) {
				$status['added'] = 1;
			} else {
				$status['error']['duplicate'] = 1;
			}
		} elseif (isset($form['action']['go'])) {
			foreach ($form['action']['go'] as $set => $tmp) {
			} /** @todo: Is this intended--empty action for foreach? */
			list($ret, $param, $isContainer) = mapv3Helper::loadParameters($containerId, false);

			if ($ret) {
				return $ret->wrap(__FILE__, __LINE__);
			}
			$idx = mapv3Helper::findParameter($param[$set], $form[$set]['goField']);

			if ($idx < 0) {
				return array(GalleryCoreApi::error(ERROR_MISSING_OBJECT, __FILE__, __LINE__), null);
			}

			switch ($form[$set]['goAction']) {
				case 'common':
					// Remove from $set, add to common; no db change
					$param['common'][] = $param[$set][$idx];
					unset($param[$set][$idx]);
					$ret = mapv3Helper::saveParameters(
						array(
							'common' => $param['common'],
							$set     => $param[$set],
						),
						$containerId
					);

					if ($ret) {
						return $ret->wrap(__FILE__, __LINE__);
					}

					break;

				case 'remove':
					// Remove from $set; delete from all items
					unset($param[$set][$idx]);
					$ret = mapv3Helper::saveParameters(
						array(
							$set => $param[$set],
						),
						$containerId
					);

					if ($ret) {
						return $ret->wrap(__FILE__, __LINE__);
					}
					$ret = mapv3Helper::deleteField(
						$form[$set]['goField'],
						$isContainer ? $containerId : 0
					);

					if ($ret) {
						return $ret->wrap(__FILE__, __LINE__);
					}
					$status['removed'] = 1;

					break;

				case 'album':
					// Remove from common, add to album; delete from non-album items
				case 'photo':
					// Remove from common, add to photo; delete from non-photo items
					$newSet           = $form[$set]['goAction'];
					$param[$newSet][] = $param[$set][$idx];
					unset($param[$set][$idx]);
					$ret = mapv3Helper::saveParameters(
						array(
							'common' => $param['common'],
							$newSet  => $param[$newSet],
						),
						$containerId
					);

					if ($ret) {
						return $ret->wrap(__FILE__, __LINE__);
					}
					$ret = mapv3Helper::deleteField(
						$form[$set]['goField'],
						$isContainer ? $containerId : 0,
						$newSet
					);

					if ($ret) {
						return $ret->wrap(__FILE__, __LINE__);
					}

					break;

				default:
					return array(GalleryCoreApi::error(ERROR_UNIMPLEMENTED, __FILE__, __LINE__), null);
			}

			if (empty($status)) {
				$status['moved'] = 1;
			}
		} elseif (isset($form['action']['picklist'])) {
			$choices = array();

			foreach (array_map('trim', explode("\n", $form['picklist'])) as $tmp) {
				if (!empty($tmp)) {
					$choices[] = $tmp;
				}
			}
			list($ret, $param) = mapv3Helper::loadParameters($containerId, false);

			if ($ret) {
				return $ret->wrap(__FILE__, __LINE__);
			}

			foreach ($param as $set => $list) {
				$idx = mapv3Helper::findParameter($list, $form['pickField']);

				if ($idx >= 0) {
					$param[$set][$idx]['choices'] = $choices;
					$ret                          = mapv3Helper::saveParameters(
						array(
							$set => $param[$set],
						),
						$containerId
					);

					if ($ret) {
						return $ret->wrap(__FILE__, __LINE__);
					}
					$status['picklist'] = 1;

					break;
				}
			}
		} // else $form['action']['reset']

		return array(null, $status);
	}

	/**
	 * Load form data for Admin template
	 *
	 * @param mixed form
	 * @param int id of container, for album-specific settings
	 * @return object GalleryStatus a status code
	 * @static
	 */
	public static function loadAdminForm(&$form, $containerId = 0) {
		global $gallery;
		list($ret, $module) = GalleryCoreApi::loadPlugin('module', 'mapv3');

		if ($ret) {
			return $ret->wrap(__FILE__, __LINE__);
		}

		$form['set']   = array();
		$form['set'][] = array(
			'key'  => 'common',
			'name' => $gallery->i18n('Common Fields'),
		);
		$form['set'][] = array(
			'key'  => 'album',
			'name' => $gallery->i18n('Album Fields'),
		);
		$form['set'][] = array(
			'key'  => 'photo',
			'name' => $gallery->i18n('Photo Fields'),
		);

		list($ret, $form['fields']) = mapv3Helper::loadParameters($containerId, false);

		if ($ret) {
			return $ret->wrap(__FILE__, __LINE__);
		}

		return null;
	}

	/**
	 * @see mapv3Interface_1_0::createmaps()
	 */
	public function createmaps($fieldNames, $containerId = 0) {
		$duplicates = array();

		foreach ($fieldNames as $fieldName) {
			list($ret, $added) = mapv3Helper::addField($fieldName, 'common', $containerId);

			if ($ret) {
				return $ret->wrap(__FILE__, __LINE__);
			}

			if (!$added) {
				$duplicates[] = $fieldName;
			}
		}

		return array(null, $duplicates);
	}

	/**
	 * @see mapv3Interface_1_0::setmapValues()
	 */
	public function setmapValues($itemId, $data) {
		list($ret, $item) = GalleryCoreApi::loadEntitiesById($itemId);

		if ($ret) {
			return $ret->wrap(__FILE__, __LINE__);
		}
		$ret = mapv3Helper::saveFieldValues($item, $data);

		if ($ret) {
			return $ret->wrap(__FILE__, __LINE__);
		}

		return null;
	}

	/**
	 * Get all the Google API key profiles.
	 *
	 * @return array GalleryStatus a status code
	 *               array Google API key profiles
	 */
	public static function getAllKeyProfiles() {
		list($ret, $mapKeys) = GalleryCoreApi::getPluginParameter('module', 'mapv3', 'mapKeys');

		if ($ret) {
			return array($ret, null);
		}

		return array(null, ($mapKeys != '') ? unserialize($mapKeys) : array());
	}

	/**
	 * Retrieve the Google API key for the current URL, or empty string if none.
	 *
	 * @return array GalleryStatus a status code
	 *               string Google API key which matches the detected current URL
	 */
	public static function fetchApiKey() {
		global $gallery;

		$urlGenerator =& $gallery->getUrlGenerator();

		// Grab the current URL directory
		$urlDir               = $urlGenerator->getCurrentUrlDir();
		list($ret, $profile)  = mapv3Helper::fetchKeyProfileForUrl($urlDir);

		if ($ret) {
			return array($ret, null);
		}
		$key = (array_key_exists('apiKey', $profile)) ? $profile['apiKey'] : '';

		return array($ret, $key);
	}

	/**
	 * Retrieve the API key profile for the given URL, or empty array if none.
	 *
	 * @param $url URL to match against the stored profiles. Directory only, no URI.
	 * @return array GalleryStatus a status code
	 *               array Google API key profile which matches the provided URL
	 */
	public static function fetchKeyProfileForUrl($url) {
		$profile = array();

		// Get the key profiles and test each one against the passed URL.
		list($ret, $allKeySets) = mapv3Helper::getAllKeyProfiles();

		if ($ret) {
			return array($ret, null);
		}

		$index = mapv3Helper::_matchLongestUrl($allKeySets, $url);

		if ($index != -1) {
			$profile = $allKeySets[$index];
		}

		return array(null, $profile);
	}

	/**
	 * Remove the API key profile associated with the given URL.
	 *
	 * @param $url URL to match against the stored profiles. Directory only, no URI.
	 *
	 * @return array GalleryStatus a status code
	 *               boolean delete was successful
	 */
	public function deleteKeyProfile($url) {
		// Get the key profiles and test each one against the passed URL. Delete the matching one.
		list($ret, $allKeySets) = mapv3Helper::getAllKeyProfiles();

		if ($ret) {
			return array($ret, false);
		}

		$index = mapv3Helper::_matchLongestUrl($allKeySets, $url);

		if ($index != -1) {
			unset($allKeySets[$index]);
		}

		$ret = mapv3Helper::_saveAllKeyProfiles($allKeySets);

		return array($ret, $found);
	}

	/**
	 * Save the given Google API key profile in the database.
	 *
	 * @param $name Name of the profile
	 * @param $url URL for the profile
	 * @param $apiKey Google API key for the profile
	 * @param $oldUrl Url of old profile to replace if editing, or blank if new
	 *
	 * @return GalleryStatus a status code
	 */
	public function saveKeyProfile($name, $url, $apiKey, $oldUrl) {
		// Get all the key profiles.
		list($ret, $allKeySets) = mapv3Helper::getAllKeyProfiles();

		if ($ret) {
			return array($ret, null);
		}
		$addNew = false;

		if (!empty($oldUrl)) {
			/* If we're editing a key, locate it by the oldUrl and modify the saved profile.
			 * If no match, then add a new profile.
			 */
			$index = mapv3Helper::_matchLongestUrl($allKeySets, $oldUrl);

			if ($index != -1) {
				$allKeySets[$index]['url']    = $url;
				$allKeySets[$index]['name']   = $name;
				$allKeySets[$index]['apiKey'] = $apiKey;
			} else {
				$addNew = true;
			}
		} else {
			$addNew = true;
		}

		if ($addNew) {
			// Add a new key profile
			$allKeySets[] = array(
				'url'    => $url,
				'name'   => $name,
				'apiKey' => $apiKey,
			);
		}
		$ret = mapv3Helper::_saveAllKeyProfiles($allKeySets);

		return $ret;
	}

	/**
	 * Find the profile index of the longest matching url in the Google API key profiles in the database.
	 *
	 * @param $profiles array Google API key profiles
	 * @param $url Url to find longest match
	 *
	 * @return integer index of longest matching url profile, or -1 if none found
	 */
	public static function _matchLongestUrl($profiles, $url) {
		$longestMatch = 0;
		$matchIndex   = -1;

		foreach ($profiles as $index => $keySet) {
			/*
			 * Go through all the keys and pick the longest (most-specific) match, in case more than
			 * one key applies to the given url. Use a case-insensitive compare. Could conceivably
			 * give a false match if URL contains a path after the host name, if the path is
			 * case-sensitive, but that's a very unlikey situation.
			 */
			$length = strlen($keySet['url']);

			if (!strncasecmp($url, $keySet['url'], $length) && $length > $longestMatch) {
				$matchIndex   = $index;
				$longestMatch = $length;
			}
		}

		return $matchIndex;
	}

	/**
	 * Save the Google API key profiles in the database.
	 *
	 * @param $profiles array Google API key profiles
	 *
	 * @return GalleryStatus a status code
	 */
	public function _saveAllKeyProfiles($profiles) {
		$ret = GalleryCoreApi::setPluginParameter('module', 'mapv3', 'mapKeys', serialize($profiles));

		return $ret;
	}

	/**
	 * Get an item color in the DB
	 *
	 * @param $itemId integer the item ID
	 * @return array  GalleryStatus a status code
	 *                string Item color
	 *
	 */
	public static function getItemColor($itemId) {
		global $gallery;

		$query = '
	SELECT 
	  [mapv3Map::value]
	FROM [mapv3Map]
	WHERE
	  [mapv3Map::field] = \'Color\'
	  AND
	  [mapv3Map::itemId] = ?
	';

		list($ret, $results) = $gallery->search($query, array($itemId), array());

		if ($ret or $results->resultCount() == 0) {
			return 'default';
		}

		$Color = $results->nextResult();

		return $Color[0];
	}

	/**
	 * Get an item zoomlevel in the DB
	 *
	 * @param $itemId integer the item ID
	 * @return zoomlevel of item
	 *
	 */
	public static function getItemZoomLevel($itemId) {
		global $gallery;

		list($ret, $defaultzoomlevel) = GalleryCoreApi::getPluginParameter('module', 'mapv3', 'zoomInLevel');

		if ($ret) {
			return '4';
		}

		$query = '
	SELECT 
	  [mapv3Map::value]
	FROM [mapv3Map]
	WHERE
	  [mapv3Map::field] = \'ZoomLevel\'
	  AND
	  [mapv3Map::itemId] = ?
	';

		list($ret, $results) = $gallery->search($query, array($itemId), array());

		if ($ret or $results->resultCount() == 0) {
			return $defaultzoomlevel;
		}

		$ZoomLevel = $results->nextResult();

		return $ZoomLevel[0];
	}

	/**
	 * Get an item GPS Coordinates from the DB
	 *
	 * @param $itemId integer the item ID
	 * @return coordinates of item
	 *
	 */
	public function getItemGPSCoordinatesFromDB($itemId) {
		global $gallery;

		$query = '
	       SELECT 
		       [mapv3Map::value]
		   FROM [mapv3Map]
           WHERE [mapv3Map::field] = \'GPS\' AND [mapv3Map::itemId] = ?
	    ';

		list($ret, $results) = $gallery->search($query, array($itemId), array());

		if ($ret or $results->resultCount() == 0) {
			return null;
		}

		$Coordinates = $results->nextResult();

		return $Coordinates[0];
	}

	/**
	 * Create an array with item properties to be used to display on the map
	 *
	 * @param $itemId integer the itemId
	 * @return array  GalleryStatus a status code
	 *                null or array of item properties
	 *
	 */
	public static function _getPropertiesForItemId($itemId) {
		global $gallery;
		$gurl       =& $gallery->getUrlGenerator();
		$properties = array();

		list($ret, $mapThumbHeight) = GalleryCoreApi::getPluginParameter('module', 'mapv3', 'ThumbHeight');

		if ($ret) {
			return array($ret, null);
		}

		// Get the item
		list($ret, $item) = GalleryCoreApi::loadEntitiesById($itemId);

		if ($ret) {
			return array($ret, null);
		}
		// Get the thumbnail information
		list($ret, $thumb) = GalleryCoreApi::fetchThumbnailsByItemIds(array($itemId));

		if ($ret) {
			return array($ret, null);
		}
		// Get the date format
		list($ret, $dateFormat) = GalleryCoreApi::getPluginParameter('module', 'core', 'format.date');

		if ($ret) {
			return array($ret, null);
		}

		$itemTitle = $item->getTitle();

		$properties = array(
			'type'        => $item->getEntityType(),
			'title'       => (empty($itemTitle)) ? preg_replace(array('/\n/', '/\r/'), array('', ''), $item->getPathComponent()) : preg_replace(array('/\n/', '/\r/'), array('', ''), $itemTitle),
			'summary'     => preg_replace(
				array('/\n/', '/\r/'),
				array('', ''),
				$item->getSummary()
			),
			'description' => preg_replace(
				array('/\n/', '/\r/'),
				array('', ''),
				$item->getDescription()
			),
			'created'     => strftime($dateFormat, $item->getOriginationTimestamp()),
		);

		if (array_key_exists($itemId, $thumb)) {
			// Add the Thumbnail Info to the array
			$pointThumb                = $thumb[$itemId];
			$properties['thumbLink']   = $gurl->generateUrl(
				array(
					'view'         => 'core.DownloadItem',
					'itemId'       => $pointThumb->getId(),
					'serialNumber' => $pointThumb->getSerialNumber(),
				),
				array(
					'forceFullUrl' => true,
				)
			);
			$properties['thumbWidth']  = $pointThumb->getWidth();
			$properties['thumbHeight'] = $pointThumb->getHeight();
		} else {
			// No Thumbnail Information
			$properties['thumbLink']   = '';
			$properties['thumbWidth']  = '100';
			$properties['thumbHeight'] = '100';
		}

		// Set the Thumbnail Bar Sizes
		$properties['thumbbarWidth']  = $mapThumbHeight * $properties['thumbWidth']  / $properties['thumbHeight'];
		$properties['thumbbarHeight'] = $mapThumbHeight * $properties['thumbHeight'] / $properties['thumbWidth'];


		return array(null, $properties);
	}

	/**
	 * Get all the GPS coordinates stored in the database
	 *
	 * @param none
	 * @return array  GalleryStatus a status code
	 *                null or array of items
	 *
	 */
	public static function getGPSItems() {
		global $gallery;
		$gurl =& $gallery->getUrlGenerator();

		// Only retrieve items that we have permissions to
		list($ret, $aclIds) = GalleryCoreApi::fetchAccessListIds('core.view', $gallery->getActiveUserId());

		if ($ret) {
			return array($ret, null);
		}

		if (empty($aclIds)) {
			return array($ret, null);
		}
		$aclMarkers = GalleryUtilities::makeMarkers(count($aclIds));

		$query = '
	SELECT 
	  [mapv3Map::itemId], [mapv3Map::value]
	FROM 
	  [mapv3Map], [GalleryAccessSubscriberMap]
	WHERE 
	  [mapv3Map::field] = \'GPS\'
	AND
	  SUBSTRING([mapv3Map::itemId],1,1) <> \'G\'
	AND
	  [GalleryAccessSubscriberMap::itemId] = [mapv3Map::itemId]
	AND
	  [GalleryAccessSubscriberMap::accessListId] in (' . $aclMarkers . ')
	';

		list($ret, $results) = $gallery->search($query, $aclIds, array());

		if ($ret or $results->resultCount() == 0) {
			return array($ret, array());
		}

		$items = array();

		while ($result = $results->nextResult()) {
			list($ret, $item) = GalleryCoreApi::loadEntitiesById($result[0]);

			if ($ret) {
				return array($ret, null);
			}

			$explodedCoord = explode(',', $result[1]);
			$itemLink      = $gurl->generateUrl(
				array(
					'view'   => 'core.ShowItem',
					'itemId' => $result[0],
				),
				array(
					'forceFullUrl' => true,
				)
			);

			$items[$result[0]] = array(
				'id'        => $result[0],
				'gps'       => $result[1],
				'color'     => mapv3Helper::getItemColor($result[0]),
				'zoomlevel' => mapv3Helper::getItemZoomLevel($result[0]),
				'itemLink'  => $itemLink,
				'parentId'  => $item->getParentId(),
				'hasChild'  => false,
				'posx'      => $explodedCoord[0],
				'posy'      => $explodedCoord[1],
			);

			list($ret, $additionalProperties) = mapv3Helper::_getPropertiesForItemId($result[0]);

			if ($ret) {
				return array($ret, null);
			}

			$items[$result[0]] = $items[$result[0]] + $additionalProperties;
		}

		return array(null, $items);
	}

	/**
	 * Private function to make an array out of the Groups from the Database save
	 *
	 * @param none
	 * @return array  GalleryStatus a status code
	 *                null or array of Groups
	 *
	 */
	public function _getGroupsFromDB() {
		global $gallery;
		$gurl     =& $gallery->getUrlGenerator();
		$platform =& $gallery->getPlatform();

		$groups = array();

		// Get the date format
		list($ret, $dateFormat) = GalleryCoreApi::getPluginParameter('module', 'core', 'format.date');

		if ($ret) {
			return array($ret, null);
		}

		list($ret, $tmpparam) = GalleryCoreApi::getPluginParameter('module', 'mapv3', 'MapGroups');

		if ($ret) {
			return array($ret, null);
		}
		$tmpgroups = explode('|', $tmpparam);

		foreach ($tmpgroups as $tmpgroup) {
			$groupinfo = explode('`', $tmpgroup);

			$thumbpic = substr(dirname(__FILE__), 0, -7) . 'images/groups/' . $groupinfo[4];
			$Tsizes   = $platform->getimagesize($thumbpic);

			if ($Tsizes !== false) {
				$thumbWidth     = $Tsizes[0];
				$thumbHeight    = $Tsizes[1];
				$thumbbarWidth  = ($Tsizes[1] != 0) ? $Tsizes[0] / $Tsizes[1] : 1;
				$thumbbarHeight = ($Tsizes[0] != 0) ? $Tsizes[1] / $Tsizes[0] : 1;
			} else {
				$thumbWidth = $thumbHeight = $thumbbarWidth = $thumbbarHeight = 1;
			}

			$groups['G' . $groupinfo[0]] = array(
				'id'             => 'G' . $groupinfo[0],
				'title'          => $groupinfo[1],
				'description'    => $groupinfo[3],
				'summary'        => $groupinfo[2],
				'created'        => strftime($dateFormat, $groupinfo[5]),
				'thumbLink'      => GalleryUtilities::convertPathToUrl(
					$thumbpic,
					array(
						'forceFullUrl' => true,
						'forceDirect'  => true,
					)
				),
				'thumbWidth'     => $thumbWidth,
				'thumbHeight'    => $thumbHeight,
				'thumbbarWidth'  => $thumbbarWidth,
				'thumbbarHeight' => $thumbbarHeight,
			);
		}

		return array(null, $groups);
	}

	/**
	 * Get all the GPS coordinates stored in the database
	 *
	 * @param none
	 * @return array  GalleryStatus a status code
	 *                null or array of items
	 *
	 */
	public static function getGPSGroups() {
		global $gallery;
		$gurl =& $gallery->getUrlGenerator();

		list($ret, $mapThumbHeight) = GalleryCoreApi::getPluginParameter('module', 'mapv3', 'ThumbHeight');

		if ($ret) {
			return array($ret, null);
		}

		$query = '
	       SELECT 
			   [mapv3Map::itemId], [mapv3Map::value]
		   FROM 
		       [mapv3Map]
           WHERE
		       [mapv3Map::field] = \'GPS\'
		   AND 
		       SUBSTRING([mapv3Map::itemId],1,1) = \'G\'
	    ';

		list($ret, $results) = $gallery->search($query, array(), array());

		if ($ret or $results->resultCount() == 0) {
			return array($ret, array());
		}

		$items                    = array();
		list($ret, $groupsinfos)  = mapv3Helper::_getGroupsFromDB();

		if ($ret) {
			return array($ret, null);
		}

		while ($result = $results->nextResult()) {
			$explodedCoord = explode(',', $result[1]);
			$itemLink      = $gurl->generateUrl(
				array(
					'view'  => 'mapv3.ShowMap',
					'Group' => $result[0],
				),
				array(
					'forceFullUrl' => true,
				)
			);

			$items[$result[0]] = array(
				'id'              => $result[0],
				'gps'             => $result[1],
				'color'           => mapv3Helper::getItemColor($result[0]),
				'zoomlevel'       => mapv3Helper::getItemZoomLevel($result[0]),
				'itemLink'        => $itemLink,
				'title'           => $groupsinfos[$result[0]]['title'],
				'description'     => $groupsinfos[$result[0]]['description'],
				'summary'         => $groupsinfos[$result[0]]['summary'],
				'created'         => $groupsinfos[$result[0]]['created'],
				'thumbLink'       => $groupsinfos[$result[0]]['thumbLink'],
				'thumbWidth'      => $groupsinfos[$result[0]]['thumbWidth'],
				'thumbHeight'     => $groupsinfos[$result[0]]['thumbHeight'],
				'thumbbarWidth'   => $groupsinfos[$result[0]]['thumbbarWidth'] * $mapThumbHeight,
				'thumbbarHeight'  => $groupsinfos[$result[0]]['thumbbarHeight'] * $mapThumbHeight,
				'regroupShowHigh' => 0,
				'regroupShowLow'  => 19,
				'parentDist'      => -1,
				'hasHiddenChild'  => false,
				'group'           => -1,
				'type'            => 'GoogleMapGroup',
				'display'         => true,
				'posx'            => $explodedCoord[0],
				'posy'            => $explodedCoord[1],
			);
		}

		return array(null, $items);
	}

	/**
	 * Create the parentsequence array
	 *
	 * @param $items array the items for which to get the parent sequence
	 *        $LevelFilterRoot the level to filter the root at
	 *        $LevelFilterAll the level to filter all other items
	 *        $albumfilter  true to enable albumfilters
	 * @return array  GalleryStatus a status code
	 *                null or array of parentsequences
	 *
	 */
	public static function getParentSequence($items, $LevelFilterRoot, $LevelFilterAll, $albumfilter) {
		$parents = array();

		// Grab the ID of the root album
		list($ret, $TheRoot) = GalleryCoreApi::getPluginParameter('module', 'core', 'id.rootAlbum');

		if ($ret) {
			return array($ret, null);
		}

		foreach ($items as $id => $currentitem) {
			if ($id != $TheRoot) {
				// retrieve the "parent" sequence for each item (except groups and root album)
				list($ret, $parents[$id]) = GalleryCoreApi::fetchParentSequence($id);

				if ($ret) {
					return array($ret, null);
				}
				list($ret, $albuminfos) = GalleryCoreApi::loadEntitiesById($parents[$id]);

				if ($ret) {
					return array($ret, null);
				}

				list($ret, $RootAlbumName) = GalleryCoreApi::loadEntitiesById($TheRoot);

				if ($ret) {
					return array($ret, null);
				}

				if ($LevelFilterRoot == 1 and $albumfilter == $RootAlbumName->getTitle()) {
					$fromLevel = count($parents[$id]) - 1;
				} elseif ($LevelFilterAll > 0) {
					$fromLevel = (count($parents[$id]) - $LevelFilterAll >= 0) ? count($parents[$id]) - $LevelFilterAll : 0;
				} else {
					$fromLevel = 0;
				}

				// get item and parent id
				list($ret, $item) = GalleryCoreApi::loadEntitiesById($id);

				if ($ret) {
					return array($ret, null);
				}
				$parentId = $parents[$id][count($parents[$id]) - 1];

				for ($i = $fromLevel; $i < count($parents[$id]); $i++) {
					$parents[$id][$i] = ($albuminfos[$i]->getTitle() != '') ? $albuminfos[$i]->getTitle() : $albuminfos[$i]->getPathComponent();
				}

				if ($fromLevel > 0) {
					for ($i = 0; $i < $fromLevel; $i++) {
						array_shift($parents[$id]);
					}
				}
			}
		}

		return array(null, $parents);
	}

	/**
	 * Get the distance in pixel between 2 coordinates for a specific zoom level
	 *
	 * @param $point1 string the coordinates for the first point (lat, lon)
	 *        $point2 string the coordinates for the second point (lat, lon)
	 *        $zoomleve the zoomlevel at which the calculation is made
	 * @return flot distance in pixels
	 *
	 */
	public function PixelDistance($point1, $point2, $zoomlevel) {
		$tmp1    = explode(',', $point1);
		$tmp2    = explode(',', $point2);
		$f       = M_PI / 180;
		$d       = acos(
			sin($tmp1[0] * $f) * sin($tmp2[0] * $f) + cos($tmp1[0] * $f) * cos($tmp2[0] * $f) * cos($tmp2[1] * $f - $tmp1[1] * $f)
		) * 6371;
		$fact    = (40074 * (cos($tmp2[0] * $f))) / 256 / 2** $zoomlevel;
		$pixdist = round($d / $fact);

		return $pixdist;
	}

	/**
	 * Get the number of items for a specific album
	 *
	 * @param $itemId integer the ID of the item, null will used the root album
	 * @return array GalleryStatus
	 *               $count, an integer
	 *
	 */
	public function getCountItemWithCoords($itemId = null) {
		global $gallery;
		$userId = $gallery->getActiveUserId();

		if ($itemId == null) {
			list($ret, $itemId) = GalleryCoreApi::getPluginParameter('module', 'core', 'id.rootAlbum');

			if ($ret) {
				return array($ret, null);
			}
		}

		if (empty($itemId)) {
			return array(GalleryCoreApi::error(ERROR_BAD_PARAMETER, __FILE__, __LINE__), null);
		}

		list($ret, $item) = GalleryCoreApi::loadEntitiesById($itemId);

		if ($ret) {
			return array($ret, null);
		}

		list($ret, $itemIds) = GalleryCoreApi::fetchDescendentItemIds($item, null, null, 'core.view');

		if ($ret) {
			return array($ret, null);
		}


		if (empty($itemIds)) {
			return array(null, 0);
		}

		$query = '
	SELECT
	 count([mapv3Map::itemId])
	FROM
	 [mapv3Map]
	WHERE
	 [mapv3Map::itemId] IN (' . GalleryUtilities::makeMarkers(count($itemIds)) . ')
	';

		list($ret, $searchResults) = $gallery->search($query, $itemIds);

		if ($ret) {
			return array($ret, null);
		}

		$count = $searchResults->nextResult();

		return array(null, $count[0]);
	}

	/**
	 * Get the routes stored in the database
	 * Also creates the Numbered markers if needed
	 *
	 * @param   $Points the array of point shown on the map
	 *          $EnableRouteNumbering boolean to use route numbering or not
	 *          $MarkerSets list of Marker Sets selected per item type
	 *          $DefaultColor list of Default colors per item type
	 * @return array GalleryStatus
	 *               $routes array of routes
	 *
	 */
	public function getRoutes($Points, $EnableRouteNumbering = false, $MarkerSets, $DefaultColors) {
		global $gallery;
		$platform =& $gallery->getPlatform();

		list($ret, $DBRoutes) = GalleryCoreApi::getPluginParameter('module', 'mapv3', 'Routes');

		if ($ret) {
			return array($ret, null);
		}
		list($ret, $impath) = GalleryCoreApi::getPluginParameter('module', 'imagemagick', 'path');

		if ($ret) {
			return array($ret, null);
		}

		if (empty($impath)) {
			$EnableRouteNumbering = false;
		}

		$mapModBaseDir = substr(dirname(__FILE__), 0, -7);

		$allrouteparam = array();
		$routeitems    = array();
		$routes        = explode('|', $DBRoutes);

		foreach ($routes as $route) {
			$tmppoint  = array();
			$tmpparam  = array();
			$rawitem   = array();
			$routeinfo = explode('`', $route);

			for ($i = 0; $i < 7; $i++) {
				$tmpparam[] = $routeinfo[$i];
			}

			GalleryUtilities::guaranteeDirExists($mapModBaseDir . 'images/routes/' . $routeinfo[1]);

			$nb = 0;

			for ($i = 7; $i < count($routeinfo); $i++) {
				if (in_array($routeinfo[$i], array_keys($Points))) {
					$rawitem[] = $routeinfo[$i];
					$nb++;

					if ($EnableRouteNumbering) {
						// Get info on the item to create the "route numerical marker"
						list($ret, $item) = GalleryCoreApi::loadEntitiesById($routeinfo[$i]);

						if ($ret) {
							return array($ret, null);
						}
						$type         = $item->getEntityType();
						$imagename    = $MarkerSets[$type];
						$defaultcolor = $DefaultColors[$type];
						$color        = mapv3Helper::getItemColor($routeinfo[$i]);
						$color        = ($color == 'default') ? $defaultcolor : $color;

						$sourceimage = $mapModBaseDir . 'images/markers/' . $imagename
						. '/marker_' . strtoupper($color) . '.png';
						$destination = $mapModBaseDir . 'images/routes/' . $routeinfo[1] . '/'
						. $nb . '-marker_' . strtoupper($color) . '.png';

						$picsize = $platform->getimagesize($sourceimage);

						$xpos = $picsize[0] / 2 - 3;
						$ypos = $picsize[1] / 2 + 2;
						/**
						 * @todo Change this to use ImageMagick's "annotate" instead of
						 * "draw text".
						 * Can't do it yet because ImageMagick 6 is required.
						 */
						/* ImageMagick's convert is picky about the format used for the
						 * -draw text argument and how it's quoted, so note the extra double
						 * quotes used before text and after the text to be drawn ($nb), and
						 * the single quotes around the text to be drawn on the image.
						 */
						$command     = array(
							$impath . 'convert',
							$sourceimage,
							'-draw',
							'"text',
							$xpos . ',' . $ypos,
							'\'' . $nb . '\'"',
							$destination,
						);
						$returnstuff = $platform->exec(array($command));
					}
					// for each item, grab the coordinates and store them in an array.
					$tmppoint[] = explode(',', mapv3Helper::getItemGPSCoordinatesFromDB($routeinfo[$i]));
				}
			}
			$routeitems[$routeinfo[1]] = $rawitem;
			$tmpparam[]                = $tmppoint;
			$allrouteparam[]           = $tmpparam;
		}

		return array(null, $allrouteparam, $routeitems);
	}
}
